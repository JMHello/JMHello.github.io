---
layout: post
title: "javasript - Array"
data: 2017-08-27 22:27:00 +0800
categories: 学习笔记
tag: javascript
---
* content
{:toc}

其他链接：

+ [ES6 - 数组的扩展]({{ '/2017/08/27/ES6-Array' | prepend: site.baseurl }})

> 以下内容全部源于： 《JavaScript高级程序设计（第3版）》

<!-- more -->

## 一、Array 类型（引用类型）

* 虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。
  * 可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。
  * 而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

### 1.1 创建数组的基本方式

* 使用 Array 构造函数
    * 给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数
      值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值
      的只有一项的数组。

```js
// 创建 length 值为 20 的数组。（即：包含 20 项的数组）
var colors = new Array(20);  

// 创建了一个包含 3 个字符串值的数组
var colors = new Array("red", "blue", "green"); 

// 创建一个包含 1 项，即字符串"Greg"的数组
var names = new Array("Greg"); 
```

* 使用数组字面量表示法
    * 数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。
    
```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组
```

* 第三行展示了在数组字面量的最后一项添加逗号的结果：在 IE 中，values 会成为一个包含 3 个项且每
  项的值分别为 1、2 和 undefined 的数组；在其他浏览器中，values 会成为一个包含 2 项且值分别为
  1 和 2 的数组。
  * 原因是 IE8 及之前版本中的 ECMAScript 实现在数组字面量方面存在 bug。
  * 由于这个 bug，导致的另一种情况如最后一行代码所示：
    * IE9+、Firefox、Opera、Safari 和 Chrome 中：该行代码可能会创建包含 5 项的数组。
    * 在 IE8 及更早版本中：可能会创建包含 6 项的数组。
  * 在像这种省略值的情况下，每一项都将获得 undefined 值；这个结果与调用 Array 构造函数时传递项数在逻辑上是相同的。
    但是 由于 IE 的实现与其他浏览器不一致，因此我们强烈建议不要使用这种语法。
    
### 1.2 读取和设置数组的值

* 在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引。
    * 如果设置某个值的索引超过了数组现有项数，数组就会自动增加到该索引值加 1 的长度。

```js
var colors = ["red", "blue", "green"]; // 定义一个字符串数组
alert(colors[0]); // 显示第一项
colors[2] = "black"; // 修改第三项
colors[3] = "brown"; // 新增第四项
```

### 1.3 数组的length属性

* 数组的项数保存在其 `length` 属性中，这个属性始终会返回 0 或更大的值。
    1. 数组的 `length` 属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。
    2. 如果将其 `length` 属性设置为大于数组项数的值，则新增的每一项都会取得 undefined 值。
    3. 利用 `length` 属性也可以方便地在数组末尾添加新项。
    4. 当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加 1。
    
```js
//----1
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 2;
alert(colors[2]); //undefined  

//-----2
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors.length = 4;
alert(colors[3]); //undefined 

//----3
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[colors.length] = "black"; //（在位置 3）添加一种颜色
colors[colors.length] = "brown"; //（在位置 4）再添加一种颜色

//-----4 【位置 3 到位置 98 实际上都是不存在的，所以访问它们都将返回 undefined。】
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[99] = "black"; // （在位置 99）添加一种颜色
alert(colors.length); // 100 
````

> 数组最多可以包含 `4 294 967 295` 个项，这几乎已经能够满足任何编程需求了。如
  果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值
  接近的数组，则可能会导致运行时间超长的脚本错误。

## 二、检测数组

1. `instanceof`：对于一个网页，或者一个全局作用域而言，使用 instanceof 操作符就能得到满意的结果。
    * instanceof 操作符的问题在于：它假定只有一个全局执行环境。如果网页中包含多个框架，那实
      际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从
      一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自
      不同的构造函数。
2. `Array.isArray()`：
    * 这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。
    * 支持 `Array.isArray()`方法的浏览器有 IE9+、Firefox 4+、Safari 5+、Opera 10.5+和 Chrome。
3. `Object.prototype.toString.call(value) == "[object Array]"`
    * 在任何值上调用 `Object` 原生的 `toString()`方法，都会返回一个`[object NativeConstructorName]`格式的字符串。
      每个类在内部都有一个`[[Class]]`属性，这个属性中就指定了上述字符串中的构造函数名。
    * 由于原生数组的构造函数名与全局作用域无关，因此使用 `toString()` 就能保证返回一致的值。

```js
if (value instanceof Array){
 //对数组执行某些操作
} 

if (Array.isArray(value)){
 //对数组执行某些操作
} 

function isArray(value){
 return Object.prototype.toString.call(value) == "[object Array]";
} 
````

## 三、转换方法

### 3.1 `toLocaleString()`、`toString()`和 `valueOf()`
* 所有对象都具有 `toLocaleString()`、`toString()`和 `valueOf()`方法。【数组继承的 toLocaleString()、toString()和 valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。】
    * `toString()`方法：返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。
    * `valueOf()`返回的还是数组。
    * `toLocaleString()`：`toLocaleString()`方法经常也会返回与 `toString()`和 `valueOf()`方法相同的值，但也不总是如此。
      * 当调用数组的 `toLocaleString()`方法时，它也会创建一个数组值的以逗号分隔的字符串。
      * 而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 `toLocaleString()`方法，而不是toString()方法。
      
```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green 
```

> 1. 在这里，我们首先显式地调用了 `toString()`方法，以便返回数组的字符串表示，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。
> 2. 接着调用 `valueOf()`方法，而最后一行代码直接将数组传递给了 `alert()`。
>      * 由于 `alert()`要接收字符串参数，所以它会在后台调用 `toString()`方法，由此会得到与直接调用 `toString()`方法相同的结果。

// 请看下面这个例子。
```js
var person1 = {
 toLocaleString : function () {
 return "Nikolaos";
 },

 toString : function() {
 return "Nicholas";
 }
};
var person2 = {
 toLocaleString : function () {
 return "Grigorios";
 },

 toString : function() {
 return "Greg";
 }
};
var people = [person1, person2];
alert(people); //Nicholas,Greg
alert(people.toString()); //Nicholas,Greg
alert(people.toLocaleString()); //Nikolaos,Grigorios 
```

> 我们在这里定义了两个对象：`person1` 和 `person2`。而且还分别为每个对象定义了一个 `toString()`
  方法和一个 `toLocaleString()`方法，这两个方法返回不同的值。然后，创建一个包含前面定义的两
  个对象的数组。在将数组传递给 alert()时，输出结果是`"Nicholas,Greg"`，因为调用了数组每一项
  的 `toString()`方法（同样，这与下一行显式调用 `toString()`方法得到的结果相同）。而当调用数组
  的 `toLocaleString()`方法时，输出结果是`"Nikolaos,Grigorios"`，原因是调用了数组每一项的
  `toLocaleString()`方法。
  
### 3.2 join()
* 使用 `join()`方法，则可以使用不同的分隔符来构建这个字符串。
* `join()`方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。
* 如果不给 `join()`方法传入任何值，或者给它传入 `undefined`，则使用逗号作为分隔符。
* IE7 及更早版本会错误的使用字符串`"undefined"`作为分隔符。
  
```js
var colors = ["red", "green", "blue"];
alert(colors.join(",")); //red,green,blue
alert(colors.join("||")); //red||green||blue 
```

> 注意：如果数组中的某一项的值是 `null` 或者 `undefined`，那么该值在 `join()`、
  `toLocaleString()`、`toString()`和 `valueOf()`方法返回的结果中以空字符串表示。

## 四、栈方法【push + pop】

### 4.1 栈

栈是一种 `LIFO`（`Last-In-First-Out`，后进先出）的数据结构，也就是最新添加的项最早被移除。
而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置——栈的顶部。

### 4.2 栈方法【影响原数组】

1. `push()`方法可以接收任意数量的参数，把它们逐个添加到数组`末尾`，并返回修改后数组的长度。
2. `pop()`方法则从数组`末尾`移除`最后一项`，减少数组的 `length` 值，然后返回移除的项。

```js
var colors = new Array(); // 创建一个数组
var count = colors.push("red", "green"); // 推入两项
alert(count); //2
count = colors.push("black"); // 推入另一项
alert(count); //3
var item = colors.pop(); // 取得最后一项
alert(item); //"black"
alert(colors.length); //2 
```

### 五、队列【push + shift】

### 5.1 队列

队列数据结构的访问规则是 `FIFO`（`First-In-First-Out`，先进先出）。队列在列表的末端添加项，从列表的前端移除项。

### 5.2 队列方法

1. `shift()`：它能够移除数组中的第一个项并返回该项，同时将数组长度减 1。
2. `push()`方法可以接收任意数量的参数，把它们逐个添加到数组`末尾`，并返回修改后数组的长度。
3. `unshift()`：能在数组前端添加任意个项并返回新数组的长度。

**正序队列：push + shift**
```js
var colors = new Array(); //创建一个数组
var count = colors.push("red", "green"); //推入两项
alert(count); //2
count = colors.push("black"); //推入另一项
alert(count); //3
var item = colors.shift(); //取得第一项
alert(item); //"red"
alert(colors.length); //2 
```

**反序队列: shift + unshift**
```js
var colors = new Array(); //创建一个数组
var count = colors.unshift("red", "green"); //推入两项
alert(count); //2 

count = colors.unshift("black"); //推入另一项
alert(count); //3
var item = colors.pop(); //取得最后一项
alert(item); //"green"
alert(colors.length); //2 
```

## 六、重排序方法

* 数组中已经存在两个可以直接用来重排序的方法：
    1. sort()
        * 在默认情况下，`sort()`方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。
        * 为了实现排序，`sort()`方法会调用每个数组项的 `toString()`转型方法，然后比较得到的字符串，以确定如何排序。
        * 即使数组中的每一项都是数值，`sort()`方法比较的也是字符串
    2. reverse()：反转数组项的顺序
* `reverse()`和 `sort()`方法的返回值是经过排序之后的数组。

```js
var values = [1, 2, 3, 4, 5];
values.reverse();
alert(values); //5,4,3,2,1 
```

* sort()方法也会根据测试字符串的结果改变原来的顺序。【因为数值 5 虽然小于 10，但在进行字符串比较时，"10"则位于"5"的前面】
```js
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5 
```

* sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。

**升序：**
```js
function compare(value1, value2) {
 if (value1 < value2) {
    return -1;
 } else if (value1 > value2) {
    return 1;
 } else {
    return 0;
 }
} 

var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); //0,1,5,10,15 
```

**降序：**

```js
function compare(value1, value2) {
 if (value1 < value2) {
    return 1;
 } else if (value1 > value2) {
    return -1;
 } else {
    return 0;
 }
}
var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 15,10,5,1,0 
```

> 更简单的写法

```js
function compare(value1, value2){
    return value2 - value1;
} 
```

## 七、操作方法

### 7.1 concat()

* `concat()`方法可以基于当前数组中的所有项创建一个新数组。
    * 这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。
    * 在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。
    * 如果传递给 concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。
    * 如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

```js
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brown 
```

### 7.2 slice(start,end)【不影响原始数组】

* slice()：能够基于当前数组中的一或多个项创建一个新数组。
    * start：要返回项的起始位置
    * end：（可选）要返回项的结束位置
* 在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。
* 如果有两个参数，该方法返回起始和结束位置之间的项——`但不包括结束位置的项`。
* 如果 slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 slice(-2,-1)与调用 slice(3,4)得到的结果相同。
* 如果结束位置小于起始位置，则返回空数组。

```js
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow
```

> 虽然 `concat()` 是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符`（+）`。而且，使用加号操作符在大多数情况下都比使用 `concat()` 方法要简便易行（特别是在拼接多个字符串的情况下）。

### 7.3 splice(start,num,item)

* 参数
    * `start`： 要删除的第一项的位置/要插入项的起始位置
    * `num`：要删除的项数
    * `item`：要插入的项

* `splice()`方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。    

*  删除：可以删除任意数量的项，只需指定 2 个参数：`splice(start,num)`
  * 例如，`splice(0,2`)会删除数组中的前两项。
  
*  插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：`splice(start,0,item)`
  * 例如，`splice(2,0,"red","green")`会从当前数组的位置 2 开始插入字符串"red"和"green"。
  
*  替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：`splice(start,num,item)`。
  插入的项数不必与删除的项数相等。
 * 例如，`splice (2,1,"red","green")`会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串"red"和"green"。

```js
var colors = ["red", "green", "blue"];
var removed = colors.splice(0,1); // 删除第一项
alert(colors); // green,blue
alert(removed); // red，返回的数组中只包含一项

removed = colors.splice(1, 0, "yellow", "orange"); // 从位置 1 开始插入两项
alert(colors); // green,yellow,orange,blue
alert(removed); // 返回的是一个空数组

removed = colors.splice(1, 1, "red", "purple"); // 插入两项，删除一项
alert(colors); // green,red,purple,orange,blue
alert(removed); // yellow，返回的数组中只包含一项
```

* 在传递的参数是负值的情况下，slice()方法会将传入的负值与字符串的长度相加。

```js
var stringValue = "hello world";
alert(stringValue.slice(-3)); //"rld"
alert(stringValue.slice(3, -4)); //"lo w" 
```

#### 2.3.3 substr(start,end)

* start： 指定子字串的开始位置

* end：（可选）表示子字符串到哪里结束。【指：返回的字符个数】

* 如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。

```js
var stringValue = "hello world";
alert(stringValue.substr(3)); //"lo world"
alert(stringValue.substr(3, 7)); //"lo worl" 
```

* 在传递的参数是负值的情况下，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0。

```js
var stringValue = "hello world";
alert(stringValue.substr(-3)); //"rld"
alert(stringValue.substr(3, -4)); //""（空字符串）
```

#### 2.3.4 substring(start,end)

* start： 指定子字串的开始位置

* end：（可选）表示子字符串到哪里结束。【指：子字符串最后一个字符后面的位置】

* 如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。

```js
var stringValue = "hello world";
alert(stringValue.substring(3)); //"lo world"
alert(stringValue.substring(3,7)); //"lo w"
```

* 在传递的参数是负值的情况下，substring()方法会把所有负值参数都转换为 0。

```js
var stringValue = "hello world";
alert(stringValue.substring(-3)); //"hello world"
alert(stringValue.substring(3, -4)); //"hel"
```

### 2.4  字符串位置方法

#### 2.4.1 indexOf(str,index)

* 从字符串的开头向后搜索子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。

* str：代表要搜索的字符串

* index：（可选）表示从字符串中的哪个位置开始搜索。

```js
var stringValue = "hello world";
alert(stringValue.indexOf("o")); //4 
alert(stringValue.indexOf("o", 6)); //7 
```

#### 2.4.2 lastndexOf(str,index)

* 从字符串的末尾向前搜索子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。

* str：代表要搜索的字符串

* index：（可选）表示从字符串中的哪个位置开始搜索。

```js
var stringValue = "hello world";
alert(stringValue.lastIndexOf("o")); //7 
alert(stringValue.lastIndexOf("o", 6)); //4 
```

#### 2.4.3 实例：找到所有匹配的子字符串

```js
var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
var positions = new Array();
var pos = stringValue.indexOf("e");
while(pos > -1){
 positions.push(pos);
 pos = stringValue.indexOf("e", pos + 1);
}

alert(positions); //"3,24,32,35,52"
```

> 这个例子通过不断增加 indexOf()方法开始查找的位置，遍历了一个长字符串。在循环之外，首
  先找到了"e"在字符串中的初始位置；而进入循环后，则每次都给 indexOf()传递上一次的位置加 1。
  这样，就确保了每次新搜索都从上一次找到的子字符串的后面开始。每次搜索返回的位置依次被保存在
  数组 positions 中，以便将来使用。

### 2.5 trim()

trim()方法创建一个字符串的副本【所以原始字符串中的前置及后缀空格会保持不变】，删除前置及后缀的所有空格，然后返回结果。

```js
var stringValue = " hello world ";
var trimmedStringValue = stringValue.trim();
alert(stringValue); //" hello world "
alert(trimmedStringValue); //"hello world" 
```

> 支持有 IE9+、Firefox 3.5+、Safari 5+、Opera 10.5+和 Chrome。此外，Firefox 3.5+、Safari 5+
  和 Chrome 8+还支持非标准的 trimLeft()和 trimRight()方法，分别用于删除字符串开头和末尾的
  空格。

### 2.6 字符串大小写转换方法
* 借鉴自 java.lang.String 中的同名方法  
toLowerCase()  
toUpperCase()

* 针对特定地区的实现  
toLocaleLowerCase()  
toLocaleUpperCase()  

>对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。  
>一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。
  
```js
var stringValue = "hello world";
alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"
alert(stringValue.toUpperCase()); //"HELLO WORLD"
alert(stringValue.toLocaleLowerCase()); //"hello world"
alert(stringValue.toLowerCase()); //"hello world" 
```

### 2.7 字符串的模式匹配方法

#### 2.7.1 match()

`match()` 方法只接受一个参数，要么是一个正则表达式，要么是一个 `RegExp` 对象。会返回一个数组。

```js
var text = "cat, bat, sat, fat";
var pattern = /.at/;

//与 pattern.exec(text)相同
var matches = text.match(pattern);
alert(matches.index); //0
alert(matches[0]); //"cat"
alert(pattern.lastIndex); //0 
```

> 如果是调用 `RegExp` 对象的 `exec()` 方法并传递本例中的字符串作为参数，那么也会得到与此相同的数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。

#### 2.7.2 search()

* `search()` 方法只接受一个参数，要么是一个正则表达式，要么是一个 `RegExp` 对象。
* 返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。
* search()方法始终是从字符串开头向后查找模式。

```js
var text = "cat, bat, sat, fat";
var pos = text.search(/at/);
alert(pos); //1 
```

#### 2.7.2 replace()

* `replace()` 方法用来替换子字符串。
* 第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。
* 如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志
```js
var text = "cat, bat, sat, fat";
var result = text.replace("at", "ond");
alert(result); //"cond, bat, sat, fat"

result = text.replace(/at/g, "ond");
alert(result); //"cond, bond, sond, fond" 
```

* 如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。

![relationship-map]({{ '/styles/images/javascript/string/string-02.png' | prepend: site.baseurl }})

* 通过这些特殊的字符序列，可以使用最近一次匹配结果中的内容。每个以"at"结尾的单词都被替换了，替换结果是"word"后跟一对圆括号，而圆括号中是被字符序列$1 所替换的单词。

```js
var text = "cat, bat, sat, fat";
result = text.replace(/(.at)/g, "word ($1)");
alert(result); //word (cat), word (bat), word (sat), word (fat) 
```

* 第二个参数也可以是一个函数。

在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在
正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始
字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace()方法的第二个参数可以实现更加精细的替换操作

* 为插入 HTML 代码定义了函数 htmlEscape()，这个函数能够转义 4 个字符：小于号、大于号、和号以及双引号。实现这种转义的最简单方式，就是使用正则表达式查找这几个字符，然后定义一个能够针对每个匹配的字符返回特定 HTML 实体的函数。
  
```js
function htmlEscape(text){
 return text.replace(/[<>"&]/g, function(match, pos, originalText){
 switch(match){
 case "<":
 return "&lt;";
 case ">":
 return "&gt;";
 case "&":
 return "&amp;";
 case "\"":
 return "&quot;";
 }
 });
}
alert(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
//&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt; 

```

#### 2.7.3 split()

* split()方法基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。
* 分隔符可以是字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。
* split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。

```js
var colorText = "red,blue,green,yellow";
var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]
var colors2 = colorText.split(",", 2); //["red", "blue"]
var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""] 
```

>对 split()中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现
 匹配项以及带有捕获组的模式，匹配的行为就不大相同了。以下是几种常见的差别。  
  IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地
 在结果中包含捕获组。  
  Firefox 3.6 及之前版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；ECMA-262 规
 定没有匹配项的捕获组在结果数组中应该用 undefined 表示。
 在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览
 器下多做一些测试。

### 2.8 localeCompare()
* localeCompare()方法比较两个字符串，并返回下列值中的一个。
*  如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
*  如果字符串等于字符串参数，则返回 0；
*  如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）。

```js
var stringValue = "yellow";
alert(stringValue.localeCompare("brick")); //1
alert(stringValue.localeCompare("yellow")); //0
alert(stringValue.localeCompare("zoo")); //-1
```

>这个例子比较了字符串"yellow"和另外几个值："brick"、"yellow"和"zoo"。因为"brick"在
 字母表中排在"yellow"之前，所以 localeCompare()返回了 1；而"yellow"等于"yellow"，所以
 localeCompare()返回了 0；最后，"zoo"在字母表中排在"yellow"后面，所以 localeCompare()
 返回了-1。
 
* localeCompare()返回的数值取决于实现。

``` js
function determineOrder(value) {
 var result = stringValue.localeCompare(value);
 if (result < 0){
 alert("The string 'yellow' comes before the string '" + value + "'.");
 } else if (result > 0) {
 alert("The string 'yellow' comes after the string '" + value + "'.");
 } else { 
}
determineOrder("brick");
determineOrder("yellow");
determineOrder("zoo"); 

```

> localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个
  方法的行为。比如，美国以英语作为 ECMAScript 实现的标准语言，因此 localeCompare()就是区分
  大小写的，于是大写字母在字母表中排在小写字母前头就成为了一项决定性的比较规则。不过，在其他
  地区恐怕就不是这种情况了。
  
### 2.9  fromCharCode()

这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 charCodeAt()执行的是相反的操作。

```js
alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
```