---
layout: post
title: "ES6 - Class的基本语法"
data: 2017-09-18 9:27:00 +0800
categories: 学习笔记
tag: ES6
---
* content
{:toc}


> 以下内容全部源于： [http://es6.ruanyifeng.com/#docs/class](http://es6.ruanyifeng.com/#docs/class)

<!-- more -->

## 一、class简介

### 1.1 简单例子
 
* 通过`class`关键字，可以定义类。

* `es5` 语法

```js
function Point (x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function() {
  return `this.x = ` + this.x + ', this.y = '+ this.y; 
};

var p = new Point(10, 20);
```

* `es6`语法：`class`改写上面的代码

```js
// 定义类
class Point {
    constructor (x, y) {
        this.x = x;
        this.y = y;
    }

    toString () {  // 等价于 Point.prototype.toString = function(){}
        return `(${this.x},${this.y})`;
    }
}

// new 命令
var p = new Point(10, 20);
console.log(p.toString()); // (10,20)

typeof Point; // function
```

### 1.2 class注意事项

*  定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。

* 方法之间不需要逗号分隔，加了会报错。

* 类必须使用`new`调用，否则会报错；普通构造函不用`new`也可以执行。。

* **类的所有方法都定义在类的`prototype`属性上面**。

* **类不存在变量提升（`hoist`）**。
    * 保证子类在父类之后定义。

* `prototype`对象的`constructor`属性，直接指向“类”的本身。

```js
Point.prototype.constructor === Point // true
```

* 类的内部所有定义的方法，都是不可枚举的（`non-enumerable`）。

```js
class Point {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}

Object.keys(Point.prototype);
// []
// 如果是es5，是可枚举的： ["toString"]

Object.getOwnPropertyNames(Point.prototype);
// ["constructor","toString"]
```

* 类的属性名，可以采用表达式。

```js
let methodName = 'getData';

class Square {
    constructor () {
        //...
    }
    [methodName] () {
        // ...
    }
}
```

### 1.3 一次向类添加多个方法 Object.assign

```js
class Point {
  constructor(){
    // ...
  }
}

Object.assign(Point.prototype, {
  toString(){},
  toValue(){}
});
```

### 1.4 constructor 方法

* `constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。
* 一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。
* `constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。

```js
class Foo {
    constructor () {
         // console.log(this); // Foo {}
        return Object.create(null);
    }
}
new Foo() instanceof Foo; //false

// new Foo() === > this ====> Object {}
```

### 1.5 类的实例对象

* 与 `ES5` 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。

```js
class Point {

  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

}

var point = new Point(2, 3);

point.toString() // (2, 3)

point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
point.__proto__.hasOwnProperty('toString') // true
```

* 类的所有实例共享一个原型对象。

```js
var p1 = new Point(2,3);
var p2 = new Point(3,2);

p1.__proto__ === p2.__proto__
//true
```

* 生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。

###  1.6 class表达式

```js
const MyClass = class Me {
    getName () {
        // console.log(Me);  // class Me {getName () {console.log(Me, this);return Me.name;}}
        return Me.name;
    }
}

let inst = new MyClass();
inst.getName(); // Me
console.log(Me.name); // ReferenceError: Me is not defined

const MyClass = class {};
```

* 这个类的名字是`MyClass`而不是`Me`，`Me`只在 `Class` 的内部代码可用，指代当前类。
* `Me`只在 `Class` 内部有定义。
* 如果类的内部没用到的话，可以省略`Me`。

* 采用 `Class` 表达式，可以写出立即执行的 `Class`。

```js
let person = class {
    constructor (name) {
        this.name = name;
    }
    
    sayName () {
        return this.name;
    }
}('jm');

person.sayName(); // jm
```

### 1.7 私有方法

* `ES6` 不提供私有方法，只能通过变通方法模拟实现。
    * 1.在命名上加以区别
        * 这种命名是不保险的，在类的外部，还是可以调用到这个方法。
    
    ```js
    class Widget {
    
      // 公有方法
      foo (baz) {
        this._bar(baz);
      }
    
      // 私有方法
      _bar(baz) {
        return this.snaf = baz;
      }
    
      // ...
    }
    ```
    
    * 2.将私有方法移出模块，因为模块内部的所有方法都是对外可见的。
    
    ```js
    class Widget {
      // foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。
    
      foo (baz) {
        bar.call(this, baz);
      }
    
      // ...
    }
    
    function bar(baz) {
      return this.snaf = baz;
    }
    ```
    
    * 3.利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值。
    
     ```js
        // bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。
        
        const bar = Symbol('bar');
        const snaf = Symbol('snaf');
        
        export default class myClass{
        
          // 公有方法
        
          foo(baz) {
            this[bar](baz);
          }
        
          // 私有方法
        
          [bar](baz) {
            return this[snaf] = baz;
          }
        
          // ...
        };
     ```