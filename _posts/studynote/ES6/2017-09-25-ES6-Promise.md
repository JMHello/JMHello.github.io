---
layout: post
title: "ES6 - Promise"
data: 2017-09-25 9:27:00 +0800
categories: 学习笔记
tag: ES6
---
* content
{:toc}


> 以下内容全部源于： [http://es6.ruanyifeng.com/#docs/promise](http://es6.ruanyifeng.com/#docs/promise)

<!-- more -->

## 一、Promise的介绍

### 1.1 Promise

* 从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。
* 简单说`Promise`就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

###  1.2 Promise特点

* `Promise`对象有以下两个特点。
    * 1.对象的状态不受外界影响。
        * `Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和 `rejected`（已失败）。
        * 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
        * 这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
    * 2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。
        * `Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled` 和 从 `pending` 变为 `rejected`。
        * 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 `resolved`（已定型）。
        * 如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。
        * 这与事件（`Event`）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。

### 1.3 Promise 缺点

1. 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。
2. 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
3. 当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

> 如果某些事件不断地反复发生，一般来说，使用 `Stream` 模式是比部署`Promise`更好的选择。

## 二、基本用法

* `Promise`构造函数接受一个**函数**作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数。
    * `resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 `pending` 变为 `resolved`），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。
    * `reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 `pending` 变为 `rejected`），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

* `Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。`then`方法可以接受两个回调函数作为参数。【这两个函数都接受`Promise`对象传出的值作为参数。】
    * 第一个回调函数是`Promise`对象的状态变为`resolved`时调用。
    * 第二个回调函数是`Promise`对象的状态变为`rejected`时调用。其中，第二个函数是可选的，不一定要提供。

> * 例1：
>    * 输出：**done**
>    * `timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（`ms`参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。

```js
function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(100).then((value) => {
  console.log(value);
});
```

> * 例2：
>    * 输出：**Promise =》 1 =》 resolved**
>    * `Promise` 新建后立即执行，所以首先输出的是 `Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。

```js
 let promise = new Promise((resolve, reject) => {
      console.log('Promise')
      resolve();
    });

    promise.then((resolved, rejected) => {
      console.log('resolved');
    });

    console.log(1);
```

> * 例3：异步加载图片
>    * 如果加载成功，就调用`resolve`方法，否则就调用`reject`方法。

```js
function loadImageAsync (url) {
      return new Promise((resolve, reject) => {
        const image = new Image();

        image.onload = function () {
            resolve(image);
        };

        image.onerror = function () {
          reject(new Error('Could not load image at ' + url));
        };

        image.src = url;
      })
    }
```

> * 例4： 用Promise对象实现的 Ajax 操作

```js
function getJson (url) {
  var promise = new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onreadystatechange = handler;
    xhr.responseType = 'json';
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.send(null);

    function handler () {
      if(xhr.readyState !== 4) {
        return;
      }

      if(xhr.readyState === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    }
  });

  return promise;
}

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error('出错了', error);
});
```

* 如果调用`resolve`函数和`reject`函数时带有参数，那么它们的参数会被传递给回调函数。
    * `reject`函数的参数通常是`Error`对象的实例，表示抛出的错误。
    * `resolve`函数的参数除了正常的值以外，还可能是另一个 `Promise` 实例。

> * 例5：
>    * `p1`和`p2`都是 `Promise` 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。
>    * 这时`p1`的状态就会传递给`p2`，即：**`p1`的状态决定了`p2`的状态**。
>        * 如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变；
>        * 如果`p1`的状态已经是`resolved`或者`rejected`，那么`p2`的回调函数将会立刻执行。
>     * 分析：
>        * `p1`是一个`Promise`，`3`秒之后变为`rejected`。
>        * `p2`的状态在`1`秒之后改变，`resolve`方法返回的是`p1`。
>        * 由于`p2`返回的是另一个 `Promise`，导致`p2`自己的状态无效了，由p1的状态决定p2的状态。
>        * 所以，后面的then语句都变成针对后者（`p1`）。
>        * 又过了`2`秒，`p1`变为`rejected`，导致触发`catch`方法指定的回调函数。

```js
var p1 = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error('fail')), 3000)
})

var p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
// Error: fail
```

> * 调用`resolve`或`reject`并不会终结 `Promise` 的参数函数的执行。
> * 例6：
>    * 调用`resolve(1)`以后，后面的`console.log(2)`还是会执行，并且会首先打印出来。
>    * 这是因为立即 `resolved` 的 `Promise` 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。

```js
new Promise((resolve, reject) => {
  resolve(1);
  console.log(2);
}).then(r => {
  console.log(r);
});
// 2
// 1
```

> 一般来说，调用`resolve`或`reject`以后，`Promise` 的使命就完成了，**后继操作应该放到`then`方法里面**，而不应该直接写在`resolve`或`reject`的后面。所以，最好在它们前面加上`return`语句，这样就不会有意外。

```js
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
})
```

## 三、 Promise.prototype.then()

* `Promise` 实例具有`then`方法，即：`then`方法是定义在原型对象`Promise.prototype`上的。
    * 作用：为 `Promise` 实例添加状态改变时的回调函数。
    * 参数： `then`方法的第一个参数是`resolved`状态的回调函数，第二个参数（可选）是`rejected`状态的回调函数。
    * 返回值：`then`方法返回的是一个**新的`Promise`实例**（注意，**不是原来那个`Promise`实例**）。
    * 因此可以采用链式写法，即`then`方法后面再调用另一个`then`方法。
 * `then`链式写法：
    * 采用链式的`then`，可以指定一组按照次序调用的回调函数。
    * 这时，前一个回调函数，有可能返回的还是一个`Promise`对象（即有异步操作），这时后一个回调函数，就会等待该`Promise`对象的状态发生变化，才会被调用。

> 例：

```js
getJson('post/1.json').then(
    post => getJson(post.commentUrl);
).then(
    comments => console.log('resolved：', comments),
    err => console.log('error：', err)
)
```

## 四、Promise.prototype.catch()

* `Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。

> * 例1：
>    * `getJSON`方法返回一个 `Promise` 对象。
>    * 如果该对象状态变为 `resolved`，则会调用`then`方法指定的回调函数。
>    * 如果异步操作抛出错误，状态就会变为`rejected`，就会调用`catch`方法指定的回调函数，处理这个错误。
>    * 另外，`then`方法指定的回调函数，如果运行中抛出错误，也会被`catch`方法捕获。

```js
getJSON('/posts.json').then(function(posts) {
  // ...
}).catch(function(error) {
  // 处理 getJSON 和 前一个回调函数运行时发生的错误
  console.log('发生错误！', error);
});

p.then((val) => console.log('fulfilled:', val))
  .catch((err) => console.log('rejected', err));

// 等同于
p.then((val) => console.log('fulfilled:', val))
  .then(null, (err) => console.log("rejected:", err));
```

> * 例2：
>    * 比较下面两种写法，可以发现 **`reject`方法的作用，等同于抛出错误**。

```js
// 写法一
var promise = new Promise((resolve, reject) => {
    throw new  Error('test');
});
promise.catch((err) => {
    console.log(err);
})

// 写法二
var promise = new Promise(function(resolve, reject) {
  try {
    throw new Error('test');
  } catch(e) {
    reject(e);
  }
});
promise.catch(function(error) {
  console.log(error);
});
```

> **如果`Promise`状态已经变成`resolved`，再抛出错误是无效的**。
> * 例3：
>   * `Promise` 在`resolve`语句后面，再抛出错误，不会被捕获，等于没有抛出。
>   * 因为 `Promise` 的状态一旦改变，就永久保持该状态，不会再变了。

```js
var promise = new Promise(function(resolve, reject) {
  resolve('ok');
  throw new Error('test');
});
promise
  .then(function(value) { console.log(value) })
  .catch(function(error) { console.log(error) });
// ok
```

> **`Promise` 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获**。
> * 例4：
>   * 一共有三个`Promise`对象：一个由`getJSON`产生，两个由`then`产生。它们之中任何一个抛出的错误，都会被最后一个`catch`捕获。

```js
getJSON('/post/1.json').then(function(post) {
  return getJSON(post.commentURL);
}).then(function(comments) {
  // some code
}).catch(function(error) {
  // 处理前面三个Promise产生的错误
});

```

> **一般来说，不要在`then`方法里面定义`Reject`状态的回调函数（即`then`的第二个参数），总是使用`catch`方法。**
> * 例4：
>   * 第二种写法要好于第一种写法，理由是第二种写法可以捕获前面`then`方法执行中的错误，也**更接近同步的写法（`try/catch`）**。因此，建议总是使用`catch`方法，而不使用`then`方法的第二个参数。

```js
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
```

> 跟传统的`try/catch`代码块不同的是，**如果没有使用`catch`方法指定错误处理的回调函数，`Promise` 对象抛出的错误不会传递到外层代码**，即不会有任何反应。
> * 例5：
>   * `someAsyncThing`函数产生的 `Promise` 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示`ReferenceError: x is not defined`，但是**不会退出进程、终止脚本执行**，`2`秒之后还是会输出`123`。
>   * 这就是说，`Promise` 内部的错误不会影响到 `Promise` 外部的代码，通俗的说法就是“Promise 会吃掉错误”。
> * 这个脚本放在服务器执行，退出码就是`0`（即**表示执行成功**）。不过，`Node` 有一个`unhandledRejection`事件，专门**监听未捕获的`reject`错误**，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。
>   * `Node` 有计划在未来废除`unhandledRejection`事件。如果 `Promise` 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为0。

```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log('everything is great');
});

setTimeout(() => { console.log(123) }, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123

// node
process.on('unhandledRejection', function (err, promise) {
  throw err;
});
```


```js

```

```js

```

```js

```

```js

```

```js

```