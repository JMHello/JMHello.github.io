---
layout: post
title: "我对前端面试的看法  （三）js"
date: 2018-02-05 09:00:00 +0800 
categories: 面试
tag: interview
---
* content
{:toc}


<!-- more -->

## 1、说说js的引入方式

> * 行内引入：让html结构变得混杂，不推荐使用
> * 内嵌：将代码写在script标签中，如果别的地方要用相同的代码，就要再copy一次，显得冗余
> * 外链：利用script标签的src属性，引入外部js文件

## 2、JSDoc注释规范

> * 

## 3、说一说有什么基本类型

> * String, Number, Boolean, Undefined, Null

## 4、说一说Undfined 和 Null

> * 当遇到判断语句时：undefined 和 null 都会自动转化成false；当undefined 不强制等于 null时，会返回true ；那为什么要设置这两个值？

> * 其实他们也是有区别的：
>   * 当你用 `typeof` 操作符去获取 `undefined` 和 `null` 的类型时，你会发现 `undefined` 为 `undefined`，而null 却是对象
>   * undefined表示的是缺少值，就是此处应有值，但是还没有添加上去
>   * null的话，代表没有对象的意思，此处不应该有值

> * undefined典型用法就是:
>   * 变量只是被声明，却还没有赋值
>   * 函数没有return语句，那么此函数默认返回undefined
>   * 调用函数时，如果对应的参数没有赋值，那么这个参数也为undefined
>   * 某个对象的属性没有赋值，也是undefined

> * null典型用法就是：
>   *  作为对象原型链的终点（Object.getPrototypeOf(Object.prototype)）
>   * 还有二叉树的遍历，判断是否遍历完，就看那个值是否为null

## 5、说一说push、pop、unshift、shift

> * 这四个方法都会影响原数组。
> * push：把想添加的项添加到数组的末尾，返回修改后数组的长度
> * pop：把数组的最后一项移除，返回移除的项
> * unshift：把想添加的项添加的数组前端，并返回新数组的长度
> * shift：移除数组第一项，返回移除的项，同时数组长度减1

## 6、说一说队列和栈

> * 队列数据结构的访问规则是先进先出
>   * 即：队列在列表的末端添加项，在列表的前端移除项
>   * 用的数组方法是：push + shift

> * 栈的数据结构是后进先出
>   * 即：最早添加的项最早被移除
>   * 用的数组方法是：push + pop

## 7、说一说你对作用域链的理解

> 先结合例子阐述自己对作用域链的理解，最后回归专业术语，总结作用域链是什么，有什么用

> * 个人对作用域的理解就是：
>   * 作用域就像一栋楼，作用域链就是连接每一层楼的阶梯，而每一层楼就是一个执行环境，里面有着当前环境的变量对象，而变量对象又保存着形参、变量、函数；
>   * 最底层楼就是当前的执行环境，而最高那层楼就是全局执行环境。
>   * 当我们要寻找标识符的时候，先在当前环境， 即：最底层寻找，就像我们要到5楼，那么我们肯定要先从1楼上去一样，
>   * 如果在当前环境没有找到想要找到的标识符，那么我们就可以沿着作用域链，继续向上一层去寻找，直到找到我们想要找的标识符为止。

> * 这里也说一下与作用域链有关的一个十分重要的属性 `[[Scope]]` 属性，这个属性在函数创建的时候就已经存在了，它的特点是静态的，不可更改的，
> * 我们可以通过这个内部属性访问当前执行环境的上一层的变量对象
> * 其实一开始知道这个属性的时候，我还是有点懵的，但我在浏览器`console.dir`一个函数出来之后，就发现有这个`[[Scopre]]`属性，然后看了一下里面的内容，
>   果然是包含了其父级的作用域链


> * 最后总结一下：
>   * 作用域链就是保存内部上下文所有变量对象的列表
>   * 作用域链的作用就是：保证对执行环境有权访问的所有变量和函数的有序访问 

## 8、说一说作用域

> * 作用域是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称寻找变量
> * 作用域又分为：全局作用域和函数作用域
> * 全局作用域定义的变量函数作用域可以访问，但是，函数作用域定义的变量全局作用域则不可以访问

## 9、说一说this

> this 是什么，有什么作用，用途是什么

> * 我对this的理解就是：
>   * this就是一个代名词，指示某个对象，方便我们通过this去调用这个对象上有的属性和方法，这个会比直接通过某对象.属性或方法要优雅得多。

> * 如果我们要用到this，必须要注意 `this` 的指向问题。
>   * 一般来说，在全局作用域中定义的函数，在全局作用域中调用，this都是指向window
>   * 一般来说，调用在某对象下定义的函数，那么this就会指向该对象
>   * 如果遇到闭包，要注意：this可能会指向window，此时需要用一个变量保留this的引用，才能保证this的指向正确

---

> * 在新出的 `es6` 语法中的箭头函数的 `this` 又稍微与 `es5` 中函数的 `this`不一样：
> * 箭头函数中的`this`的指向取决于箭头函数定义时所处的环境
> * 而 `es5` 中函数中的 `this` 中的指向取决于调用表达式的形式

---

> * 如果遇到混杂函数（就是既有箭头函数，又有普通函数），就要注意this可能会指向当前对象，也可能会指向window


## 10、如何理解闭包

> 先说说闭包是什么，有什么特点，然后再说一说优点，最后说一说缺点，最后说一说应用场景

> * 闭包：是指有权访问另一个函数作用域的函数
> * 特点：
>   * 函数嵌套函数
>   * 内部函数可以引用外层的参数和变量
>   * 参数和变量不会被垃圾回收机制回收
> * 好处：建立私有变量和特权方法，避免全局变量的污染，如果希望一个变量长期驻扎在内存中
> * 缺点：由于大量的变量参数无法被回收，所以内存会容易过大，导致内存泄漏
> * 应用场景：
>   * 模块化代码
>   * 建立私有成员（有时候单例模式也会用到闭包）

## 10、谈一谈面向对象

> 整体阐述面向对象是什么，再说一说js的面向对象，接着说一说面向对象的特点

> * 面向对象，就像我们的世界。
> * 比如说：人，它不都有一个鼻子，两只眼睛？这其实是很宽泛的去描述一个人。
> * 因此，人，其实是抽象的，它描述的是一类特定类别的东西。
> * 你我是人，人是动物
> * 但是你我除了有一个鼻子，两只眼睛外，也有许多地方不同的！
> * 比如，我的性别是女的，你的性别是男的，比如说，你的爱好是打篮球，我的爱好是学习等等
> * 所以，你我其实是基于抽象 的“人”的具体化的人。

> * 许多编程语言都有面向对象，例如java，c；当然，javascript也不例外。
> * 面向对象都有一个语言标识，就是类，我们可以通过类去创建任意属性和方法。
> * 不过对于javascript来说，它没有类的概念的
> * 在es6的class语法糖未出现之前，js创建类都是基于函数创建的。

> * 面向对象有以下特点：
>   * 抽象性：就像刚刚说到的人一样，它只是一类特定类别的大类，具有这些特定类别都共有的特点，所以是宽泛的、抽象的
>   * 封装性：把功能写成方法，js里面就是函数
>   * 继承性：子类可以继承父类的属性和方法，避免重复写相同的代码，就像刚刚说到的 “你我” 和 “人”，你我就是子类，“人”就是父类
>   * 多态性：就是多种表现形态，比如学生对象有一个跑步的方法，那么可以在方法中根据不同学生的体质来决定学生跑多少米

## 11、说一说如何创建对象

> * 创建对象有4种方法
>   * 工厂模式创建对象
>       * 直接把函数和变量写在函数体内，将这些属性和方法存到一个对象里，最终返回这个对象
>       * 缺点：无法判断对象的归属
>   * 构造函数模式创建对象
>       * 没有显式创建一个对象，将属性方法都赋值给this，没有return 语句；可传递参数
>       * 缺点：功能相同的函数，重复声明浪费空间
>   * 原型模式创建对象
>       * 主要依靠`prototype`属性去创建对象
>       * 缺点：共享问题，无法传递参数
>   * 组合模式创建对象（构造函数和原型）
>       * 属性写在构造函数里，方法写在`prototype`上

## 12、说一说继承

> * 继承主要有4种方法
>   * 原型链继承
>       * 原理：利用原型，让一个引用类型继承另外一个引用类型的属性和方法
>       * 缺点：construtor的指向，共享问题，无法传参
>   * 借用构造函数继承
>       * 原理：基于函数可以控制自己的执行环境去实现继承，关键代码：父类.call(this, 参数)，这一行代码放在子类的构造函数中
>       * 缺点：无法继承原型链上的属性和方法
>       * 优点：解决了construtor的指向和传递参数的问题
>   * 组合继承
>       * 结合原型链继承以及构造函数继承
>       * 缺点：两次调用父类的构造函数（第一次调用是在子类构造函数中借用构造函数，从而继承父类属性；第二次调用，是将父类实例引用给子类，让子类继承父类原型上的方法）
>   * 寄生组合式继承
>       * 主要解决两次调用父类的构造函数这个问题
>       * 实现主要函数是 `inheritPrototype`，主要思路是
>           * 传递两个参数，一个是subType,子类构造函数，superType,父类构造函数
>           * const proto = Object.create(superType.prototype)，copy一份父类的原型
>           * proto.constructor = subType，设定construtor的指向，这里要指向子类
>           * subType.prototype = proto，将子类原型指向proto

## 13、请描述一下 cookies，sessionStorage 和 localStorage 的异同？

> 这里先说说相同的地方，再说不同的地方

> * 相同点：它们都是用来存储数据的，而且都存储在客户端

> * 不同点： 
>   * 存储大小不一样：
>       * `cookie` 不能超过`4k`
>       * 而`sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比cookie大得多，可以达到5M
>   * 有效时间不同：
>       * `localStorage` 存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据
>       * `sessionStorage` 存储的数据在当前浏览器窗口关闭后自动删除
>       * `cookie` 在所设置的过期时间之前一直有效，即使浏览器被关闭，除非手动删除cookie
>   * 数据与服务器之间的交互方式不同
>       * `cookie` 的数据会自动传递到服务器，服务器端也可以发送cookie到客户端（通过那个头字段`Set-Cookie`）
>       * `sessionStorage` 和 `localStorage` 不会自动将数据发送给服务器，仅在本地保存

## 14、深拷贝与浅拷贝
  
> 先说一说分别是什么，区别在哪里，如何实现

> * 浅拷贝：指不会开辟新的栈，浅拷贝后，两个对象的地址指向是相同的，一方的属性改变了，另外一方也会跟着变化
> * 深拷贝：深拷贝会开辟新的栈，两个对象的地址都是不一样的，一方的属性改变不会影响另外一方

> * 浅拷贝最简单的实践方法：直接赋值，即：创建一个对象，然后将这个对象赋值给一个新变量；还有另外一个方法：Object.assign()
> * 深拷贝：递归实现或者用 JSON.stringify() 以及 JSON.parse() 实现 

## 15、创建一个有十行十列的表格（不准 `innerHTML`），并给每个单元格绑定事件。

> 考点在于关于表格的`DOM`操作以及事件委托

> * [demo](/effects/demo/js/dom/table.html)

```js
  const table = createTable()

  // 事件委托
  table.onclick = function (e) {
    const target = e.target

    if (target.tagName.toLocaleLowerCase() === 'td') {
      alert(target.innerHTML)
    }
  }
  
  /**
   * 创建表格
   * @returns {Element|*}
   */
  function createTable() {
    const table = document.createElement('table')
    table.border = 1
    table.width = 600
    let tBody = document.createElement('tBody')
    table.appendChild(tBody)
    createRowAndCol(tBody)
    document.body.appendChild(table)
    return table
  }

  /**
   * 创建行列
   * @param tbody
   * @returns {*}
   */
  function createRowAndCol(tbody) {
    for (let i = 0; i < 10; i++) {
      // 插入行
      tbody.insertRow(i)
      for (let j = 0; j < 10; j++) {
        // 插入列
        tbody.rows[i].insertCell(j)
        tbody.rows[i].cells[j].appendChild(document.createTextNode(`${i}${j}`))
      }
    }

    return tbody
  }
```

## 16、说一说原型、原型链

> * 对于js来说，继承的实现主要依靠原型链来实现。
> * 当我们访问一个属性的时候，如果在实例里找不到这个属性，就会到原型链去寻找
> * 原型链就像一座桥，是由原型去搭建这座桥。

> * 每一个函数在创建之后，都会有 `prototype` 这个属性，这个属性指向函数的原型对象，我们称这个为显式原型
> * js的每一个对象都有一个内置的 `[[prototype]]` ，大多数浏览器会支持通过 `__proto__` 去访问，我们称这个为隐式原型

> * 隐式原型与显式原型的关系是：隐式原型会指向创建这个对象的构造函数的 `prototype`

> * 对于显式原型来说：显式原型可以用来实现基于原型的继承和属性的共享
>   * 比如在人这个类的`prototype`中添加跑步这个方法，学生也是人，学生继承了人这个类后，那么学生类实例化出来的对象中也会有跑步这个方法
> * 对于隐式原型来说：隐式原型主要用来构造原型链

## 17、说一说new操作符

> * new操作符一般用来新建一个对象
> * new操作符会做以下事情
>   * 创建一个新对象
>   * 新对象的隐形原型会指向创建这个对象的构造函数的prototype
>   * 调用call强行转换作用环境

## 18、说一说Object.create()的原理

> * 新建一个空函数，就是这个函数什么都不做
> * 将传入的对象赋值给此函数的prototype
> * 返回 一个新对象

## 19、将给定的格式转化为千分位的格式

> * 10000转化为10,000

> * 匹配规则：
>   * 主要找位置，从后开始向前找，3个数字为一组，3个数字前添加一个逗号，如果是100000这种状态，最前面1那里则不需要添加逗号，即 100,000

```js
const reg = /(?=((?!\b)\d{3})+$)/g
'1000000'.replace(reg, ',')
```

## 20、过滤年月日

> * 年，四位数字，比如 2017
> * 月，一位或者两位数字，第一位只能是 0 或者 1 ，比如 01 合法、1合法、10 合法
> * 日，一位或者两位数字，第一位可能是 0、1、2、3，比如 01 合法、1合法、10 合法、21 合法

```js
const reg = /(\d{4})([01]?\d)([0123]?\d)/g
reg.exec('20130213')  //结果： ['20130213', '2013', '02', '13']
```

## 21、说一说事件模型

> * 标准的事件模式由三部分组成：事件捕获、处于目标、事件冒泡    
> * 常用的就是处于目标、事件冒泡

## 22、说说DOM的操作都有哪些

> * 添加节点：
>   * 父节点.appendChild(新节点)
>   * 父节点.insertBefore(新节点, 参考节点)
> * 删除节点：父节点.removeChild(想要删除的节点)
> * 替换节点：父节点.replaceChild(新节点，要替换的节点)
> * 拷贝节点：要拷贝的节点.cloneNode()
>   * 要拷贝的节点.cloneNode(true)：表面深复制，复制节点及整个子节点树
>   * 要拷贝的节点.cloneNode(false)：表面浅复制，复制当前节点

## 23、说说childNodes 与 Children 的异同

> * 相同点：都是表示子节点，都保存这一个类数组对象`NodeList`
> * 不同点：`childNodes` 包含文本节点，而`children`不会包含文本节点

## 24、javascript的typeof返回哪些数据类型

> * Boolean, String, Number, Object, Function, Undefined

## 25、说说location

> * location主要用来提供文档信息，我们也可以用其来导航
> * 有这些属性：`location.href  location.protocol  location.pathname  location.search  location.hash`
> * 方法 `location.reload()`，如果传进参数 `true` ，则表示不用缓存，重新从服务器拉取数据

## 26、说一说navigator

> * `navigator`：主要保留客户端信息
> * 尝使用的：`navigator.userAgent`，表示浏览器的用户代理

## 26、说一说history

> * history主要保存用户上网记录，其从用户打开浏览器那一刻算起
> * history.go(-1)/history.back()：后退 
> * history.go(1)/ history.forward()：前进 

## 27、说说有什么对话框

> * alert：警告框
> * confirm：确认框
> * prompt：提示框

## 28、说说ajax

> 发送ajax请求有多少个步骤？如何判定发送成功？（readyState和onreadystatechange）

> * 新建连接：创建 `xhr` 对象
> * 打开连接: `xhr.open`
> * 发送数据：`xhr.send`
> * 接收数据：`xhr.onreadystatechange + xhr.readyState + xhr.status`
>   * 由于 `Ajax` 是异步的，所以 `onreadystatechange` 事件是放在 `xhr.open()` 之前的
