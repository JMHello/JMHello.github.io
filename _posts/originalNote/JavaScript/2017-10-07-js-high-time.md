---
layout: post
title: "javascript - 高级定时器"
data: 2017-10-07 12:27:00 +0800
categories: 原创
tag: javascript
---
* content
{:toc}

* 参考资料
    + 《JavaScript高级程序设计（第3版）》 22.3 高级定时器

* 相关链接
    + [javascript - 定时器]({{ '/2017/10/06/js-time' | prepend: site.baseurl }})

<!-- more -->

## 一、简述定时器的机制

看以下例子：

```js
var btn = document.getElementById("my-btn");
btn.onclick = function(){
 setTimeout(function(){
  document.getElementById("message").style.visibility = "visible";
 }, 250);
 //其他代码
}; 
```

> *上述代码的解析：
>   * 先给按钮设置了一个事件处理程序，事件处理程序里设置了一个 `250ms` 后调用的定时器。
>   * 点击按钮后，先把 `onclick` 事件处理程序添加到任务队列中。
>   * 该事件处理程序执行后，再设置定时器，`250ms`后，指定的代码才被添加到队列中等待执行。
>   * 如果队列为空，即：没有其他代码等待执行，那么定时器内的代码就会执行；
     如果队列不为空，即：有其他代码等待执行，那么定时器内的代码就会等到队列中的代码执行完后执行。

> * 总结：
>   * 定时器只是用来**计划**代码在未来的某个时间执行。
>   * 定时器所指定的时间间隔表示**何时将定时器的代码添加到队列，而不是何时实际执行代码**。
>   * 在`js`中没有任何代码是立刻执行的，除非进程是空闲的，而不管它们是如何添加到队列中。

## 二、重复的定时器 - setInterval()

### 2.1 setInterval()问题的阐述

> * `setInterval()`：每隔指定的时间就执行一次代码。说明了它创建的定时器确保了定时器代码规则地插入队列中。

> * 但这个创建定时器的方式也存在问题：
>    * 定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。
    
> * `JavaScript` 引擎能避免这个问题：
>    * 当使用 `setInterval()`时，**仅当没有该定时器的任何其他代码实例**时，才将定时器代码添加到队列中。
>    * 这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

### 2.2 setInterval()问题展示的例子

> * `setInterval()`问题：
>    * 某些间隔会被跳过。
>    * 多个定时器的代码执行之间的间隔可能会比预期的小。

> * 先看以下例子：
>    * 假设，某个 `onclick` 事件处理程序使用 `setInterval()`设置了一个 `200ms` 间隔的重复定时器。
>    * 如果事件处理程序花了 `300ms` 多一点的时间完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器代码的情况。

![relationship-map]({{ '/styles/images/javascript/time/time-01.png' | prepend: site.baseurl }})

> * 上图分析：
>    * 第 1 个定时器是在 `205ms` 处添加到队列中的，但是直到过了 `300ms` 处才能够执行。
>    * 当执行这个定时器代码时，在 405ms 处又给队列添加了另外一个副本。
>    * 在下一个间隔，即 `605ms` 处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。
>    * 结果是，在这个时间点上的定时器代码不会被添加到队列中。
>    * 结果在 `5ms` 处添加的定时器代码结束之后，`405ms` 处添加的定时器代码就立刻执行。

### 2.2 setInterval()问题解决方法

> * 解决上述两个问题的方法：用如下模式使用链式 `setTimeout()` 调用。
>    * 这个模式链式调用了 `setTimeout()`，每次函数执行的时候都会创建一个新的定时器。
>    * 第二个 `setTimeout()`调用使用了 `arguments.callee` 来获取对当前执行的函数的引用，并为其设置另外一个定时器。
>    * 这样做的好处：
>        * **在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔**。
>        * 它可以**保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行**。

```js
setTimeout(function(){
 //处理中
 setTimeout(arguments.callee, interval);
}, interval); 
```

## 三、Yielding Processes 

### 3.1 长时间运行脚本的制约

* **长时间运行脚本的制约**：**如果代码运行超过特定的时间或者特定语句数量就不让它继续执行**。
* 如果代码达到了这个限制，会弹出一个浏览器错误的对话框：告诉用户某个脚本会用过长的时间执行，询问是允许其继续执行还是停止它。
* 定时器是绕开此限制的方法之一。   

### 3.2 脚本长时间运行问题产生的原因

* 脚本长时间运行的问题产生的原因：
    * 过长的、过深嵌套的函数调用。
    * 进行大量处理的循环。

### 3.3 数组分块技术（array chunking)

* 长时间运行的循环通常遵循以下模式：

```js
for (var i=0, len=data.length; i < len; i++){
 process(data[i]);
} 
```

> * 这个模式的问题在于 **要处理的项目的数量在运行前是不可知** 的。【 **数组中的项目数量直接关系到执行完该循环的时间长度**。】
>    * 例子：如果完成 `process()`要花 `100ms`，只有 `2` 个项目的数组可能不会造成影响，但是 `10` 个的数组可能会导致脚本要运行一秒钟才能完成。
> * 由于 `JavaScript` 的执行是一个阻塞操作，脚本运行所花时间越久，用户无法与页面交互的时间也越久。

> * 在展开循环前，需先考虑以下两个问题：
>    1. 该处理是否必须同步完成？
>        * 如果这个数据的处理会造成其他运行的阻塞，那么最好不要改动它。
>        * 如果你对这个问题的回答确定为“否”，那么将某些处理推迟到以后是个不错的备选项。 
>    2. 数据是否必须按顺序完成？
>        * 通常，数组只是对项目的组合和迭代的一种简便的方法而无所谓顺序。
>        * 如果**项目的顺序不是非常重要**，那么可能可以将某些处理推迟到以后。

> * 当你发现**某个循环占用了大量时间**，同时对于上述两个问题，你的回答都是“否”，那么你就可以使用定时器分割这个循环。
> * 这是一种叫做**数组分块**（`array chunking`）的技术，小块小块地处理数组，通常每次一小块。
>   * 基本的思路：为要处理的项目创建一个队列，然后使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。

```js
function chunk(array, process, context){
    setTimeout(function(){
        var item = array.shift();
        
        process.call(context, item);
        
        if (array.length > 0){
          setTimeout(arguments.callee, 100);
        }
    }, 100);
} 
```