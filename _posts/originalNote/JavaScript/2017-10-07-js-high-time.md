---
layout: post
title: "javascript - 高级定时器"
data: 2017-10-07 12:27:00 +0800
categories: 原创
tag: javascript
---
* content
{:toc}

* 参考资料
    + 《JavaScript高级程序设计（第3版）》 22.3 高级定时器

* 相关链接
    + [javascript - 定时器]({{ '/2017/10/06/js-time' | prepend: site.baseurl }})

<!-- more -->

## 一、简述定时器的机制

看以下例子：

```js
var btn = document.getElementById("my-btn");
btn.onclick = function(){
 setTimeout(function(){
  document.getElementById("message").style.visibility = "visible";
 }, 250);
 //其他代码
}; 
```

> *上述代码的解析：
>   * 先给按钮设置了一个事件处理程序，事件处理程序里设置了一个 `250ms` 后调用的定时器。
>   * 点击按钮后，先把 `onclick` 事件处理程序添加到任务队列中。
>   * 该事件处理程序执行后，再设置定时器，`250ms`后，指定的代码才被添加到队列中等待执行。
>   * 如果队列为空，即：没有其他代码等待执行，那么定时器内的代码就会执行；
     如果队列不为空，即：有其他代码等待执行，那么定时器内的代码就会等到队列中的代码执行完后执行。

> * 总结：
>   * 定时器只是用来**计划**代码在未来的某个时间执行。
>   * 定时器所指定的时间间隔表示**何时将定时器的代码添加到队列，而不是何时实际执行代码**。
>   * 在`js`中没有任何代码是立刻执行的，除非进程是空闲的，而不管它们是如何添加到队列中。

## 二、重复的定时器 - setInterval()

### 2.1 setInterval()问题的阐述

> * `setInterval()`：每隔指定的时间就执行一次代码。说明了它创建的定时器确保了定时器代码规则地插入队列中。

> * 但这个创建定时器的方式也存在问题：
>    * 定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。
    
> * `JavaScript` 引擎能避免这个问题：
>    * 当使用 `setInterval()`时，**仅当没有该定时器的任何其他代码实例**时，才将定时器代码添加到队列中。
>    * 这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。

### 2.2 setInterval()问题展示的例子

> * `setInterval()`问题：
>    * 某些间隔会被跳过。
>    * 多个定时器的代码执行之间的间隔可能会比预期的小。

* 先看以下例子：
    * 假设，某个 `onclick` 事件处理程序使用 `setInterval()`设置了一个 `200ms` 间隔的重复定时器。
    * 如果事件处理程序花了 `300ms` 多一点的时间完成，同时定时器代码也花了差不多的时间，就会同时出现跳过间隔且连续运行定时器代码的情况。

![relationship-map]({{ '/styles/images/javascript/time/time-01.png' | prepend: site.baseurl }})

* 上图分析：
    * 第 1 个定时器是在 `205ms` 处添加到队列中的，但是直到过了 `300ms` 处才能够执行。
    * 当执行这个定时器代码时，在 405ms 处又给队列添加了另外一个副本。
    * 在下一个间隔，即 `605ms` 处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。
    * 结果是，在这个时间点上的定时器代码不会被添加到队列中。
    * 结果在 `5ms` 处添加的定时器代码结束之后，`405ms` 处添加的定时器代码就立刻执行。

### 2.2 setInterval()问题解决方法

> * 解决上述两个问题的方法：用如下模式使用链式 `setTimeout()` 调用。
>    * 这个模式链式调用了 `setTimeout()`，每次函数执行的时候都会创建一个新的定时器。
>    * 第二个 `setTimeout()`调用使用了 `arguments.callee` 来获取对当前执行的函数的引用，并为其设置另外一个定时器。
>    * 这样做的好处：
>        * **在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔**。
>        * 它可以**保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行**。

```js
setTimeout(function(){
 //处理中
 setTimeout(arguments.callee, interval);
}, interval); 
```


